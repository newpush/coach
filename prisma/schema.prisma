// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

// --------------------------------------
// User & Auth (NuxtAuth / NextAuth Standard)
// --------------------------------------

model User {
  id            String    @id @default(uuid())
  name          String?
  email         String    @unique
  emailVerified DateTime?
  image         String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  
  isAdmin       Boolean   @default(false)

  // Settings for Coaching
  ftp           Int?      // Functional Threshold Power (Watts)
  maxHr         Int?      // Max Heart Rate
  weight        Float?    // Weight in kg (for W/kg calcs)
  dob           DateTime? // Date of birth for age-based metrics
  altitude      Int?      // Home altitude in meters

  // User Settings
  language      String?   @default("English")
  weightUnits   String?   @default("Kilograms") // "Kilograms", "Pounds"
  height        Int?      // cm
  heightUnits   String?   @default("cm") // "cm", "ft/in"
  distanceUnits String?   @default("Kilometers") // "Kilometers", "Miles"
  temperatureUnits String? @default("Celsius") // "Celsius", "Fahrenheit"
  restingHr     Int?
  form          String?   @default("Absolute value") // "Absolute value", "Percentage"
  visibility    String?   @default("Private") // "Private", "Public", "Followers Only"
  sex           String?   // "Male", "Female", "Other"
  city          String?
  state         String?
  country       String?
  timezone      String?
  
  // Custom Zones
  hrZones       Json?     // Array of { name, min, max }
  powerZones    Json?     // Array of { name, min, max }

  // AI Coach Settings
  aiPersona            String?  @default("Supportive") // "Analytical", "Supportive", "Drill Sergeant", "Motivational"
  aiModelPreference    String?  @default("flash") // "flash" (faster, cheaper) or "pro" (higher quality, more expensive)
  aiAutoAnalyzeWorkouts Boolean @default(false) // Auto-analyze workouts on sync
  aiAutoAnalyzeNutrition Boolean @default(false) // Auto-analyze nutrition logs on sync

  // Athlete Profile Scores (1-10 scale, updated periodically from profile generation)
  currentFitnessScore       Int?      // Current overall fitness level
  recoveryCapacityScore     Int?      // Ability to recover from training
  nutritionComplianceScore  Int?      // Nutrition adherence and quality
  trainingConsistencyScore  Int?      // Training consistency and adherence
  profileLastUpdated        DateTime? // When profile scores were last updated
  
  // Score Explanations (AI-generated insights and improvement guidance)
  currentFitnessExplanation       String?   // Why this fitness score, how to improve
  recoveryCapacityExplanation     String?   // Recovery factors and improvement steps
  nutritionComplianceExplanation  String?   // Nutrition quality analysis and guidance
  trainingConsistencyExplanation  String?   // Consistency patterns and recommendations
  
  // Structured Score Explanations (JSON format for rich UI display)
  currentFitnessExplanationJson       Json?   // Structured explanation with sections and recommendations
  recoveryCapacityExplanationJson     Json?   // Structured recovery analysis
  nutritionComplianceExplanationJson  Json?   // Structured nutrition analysis
  trainingConsistencyExplanationJson  Json?   // Structured consistency analysis

  // Relations
  accounts      Account[]
  sessions      Session[]
  integrations    Integration[] // External App Connections (Whoop, Intervals)
  workouts        Workout[]
  fitFiles        FitFile[]
  plannedWorkouts PlannedWorkout[]
  dailyMetrics    DailyMetric[]
  wellness        Wellness[]
  nutrition       Nutrition[]
  reports         Report[]
  activityRecommendations ActivityRecommendation[]
  trainingAvailability TrainingAvailability[]
  weeklyTrainingPlans WeeklyTrainingPlan[]
  scoreTrendExplanations ScoreTrendExplanation[]
  chatParticipations ChatParticipant[]
  llmUsage LlmUsage[]
  syncQueue SyncQueue[]
  goals         Goal[]
  apiKeys       ApiKey[]

  // Coaching Relations
  coaches    CoachingRelationship[] @relation("AthleteRelation")
  athletes   CoachingRelationship[] @relation("CoachRelation")
  invites    CoachingInvite[]
}

// --------------------------------------
// API Key Management
// --------------------------------------

model ApiKey {
  id            String    @id @default(uuid())
  userId        String
  name          String
  key           String    @unique // Hashed key
  prefix        String    // First few characters for identification (e.g., "cw_...")
  
  lastUsedAt    DateTime?
  expiresAt     DateTime?
  
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  user          User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([key])
}

// --------------------------------------
// Coaching System
// --------------------------------------

model CoachingRelationship {
  id        String   @id @default(uuid())
  coachId   String
  athleteId String
  
  // Status
  status    String   @default("ACTIVE") // ACTIVE, SUSPENDED
  
  // Permissions (reserved for future granular control, currently implicitly "ALL")
  permissions Json?  // e.g. { "view_workouts": true, "edit_plans": true }

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  coach     User     @relation("CoachRelation", fields: [coachId], references: [id], onDelete: Cascade)
  athlete   User     @relation("AthleteRelation", fields: [athleteId], references: [id], onDelete: Cascade)

  @@unique([coachId, athleteId])
  @@index([coachId])
  @@index([athleteId])
}

model CoachingInvite {
  id        String   @id @default(uuid())
  athleteId String   // The user issuing the invite (The Athlete)
  code      String   @unique // Short alphanumeric code (e.g., "TR-8821")
  
  expiresAt DateTime
  
  usedBy    String?  // ID of the Coach who used it (optional, mostly for audit)
  status    String   @default("PENDING") // PENDING, ACCEPTED, EXPIRED

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  athlete   User     @relation(fields: [athleteId], references: [id], onDelete: Cascade)
  
  @@index([code])
}

model Goal {
  id          String   @id @default(uuid())
  userId      String
  type        String   // "BODY_COMPOSITION", "EVENT", "PERFORMANCE", "CONSISTENCY"
  
  // Display
  title       String
  description String?
  
  // Target definition
  metric      String?  // "weight_kg", "ftp_watts", "event_date", "weekly_hours"
  currentValue Float?  // Snapshot at start
  targetValue Float?   // The goal value
  startValue  Float?   // Value at creation
  targetDate  DateTime?
  
  // Event specific
  eventDate   DateTime?
  eventType   String?  // "race", "challenge"
  
  // Status
  status      String   @default("ACTIVE") // ACTIVE, COMPLETED, ARCHIVED
  priority    String   @default("MEDIUM") // LOW, MEDIUM, HIGH
  
  // AI Context
  aiContext   String?  @db.Text
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId])
}

model Account {
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([provider, providerAccountId])
}

model Session {
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model VerificationToken {
  identifier String
  token      String
  expires    DateTime

  @@id([identifier, token])
}

// --------------------------------------
// App Integrations (The "Senses")
// --------------------------------------

// Stores tokens for external fitness apps (Intervals.icu, Whoop, Strava)
// Distinct from 'Account' which is for Login/SSO
model Integration {
  id             String    @id @default(uuid())
  userId         String
  provider       String    // "intervals", "whoop", "strava", "garmin"
  
  // Auth Data
  accessToken    String
  refreshToken   String?
  expiresAt      DateTime?
  externalUserId String?   // The user's ID in the external system
  scope          String?   // What permissions we have

  // Sync Status
  lastSyncAt     DateTime?
  initialSyncCompleted Boolean? @default(false) // Track if initial history has been synced
  syncStatus     String?   // "SUCCESS", "FAILED", "SYNCING"
  errorMessage   String?

  user           User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, provider])
}

// --------------------------------------
// Normalized Fitness Data
// --------------------------------------

// A unified structure for workouts from any provider
model Workout {
  id              String   @id @default(uuid())
  userId          String
  externalId      String   // ID from the source (e.g., Strava Activity ID)
  source          String   // "intervals", "strava"
  
  // Core Data
  date            DateTime
  title           String
  description     String?  @db.Text
  type            String?  // "Ride", "Run", "WeightTraining"

  // Performance Metrics
  durationSec     Int
  distanceMeters  Float?
  elevationGain   Int?
  
  // Power & Heart Rate
  averageWatts    Int?
  maxWatts        Int?
  normalizedPower Int?
  weightedAvgWatts Int?
  averageHr       Int?
  maxHr           Int?
  averageCadence  Int?
  maxCadence      Int?
  averageSpeed    Float?
  
  // Training Load & Intensity
  tss             Float?   // Training Stress Score
  trainingLoad    Float?   // icu_training_load
  intensity       Float?   // Intensity Factor (0-1+ scale)
  kilojoules      Int?
  trimp           Int?
  
  // Performance Metrics
  ftp             Int?     // FTP at time of activity
  variabilityIndex Float?  // Power variability (NP/AP)
  powerHrRatio    Float?   // Power/HR efficiency
  efficiencyFactor Float?  // Power/HR at aerobic intensities
  decoupling      Float?   // Aerobic efficiency metric
  polarizationIndex Float? // Training distribution metric
  
  // Training Status (from Intervals.icu)
  ctl             Float?   // Chronic Training Load (Fitness)
  atl             Float?   // Acute Training Load (Fatigue)
  
  // Subjective Metrics
  rpe             Int?     // Rate of Perceived Exertion
  sessionRpe      Int?     // Session RPE
  feel            Int?     // How the workout felt (1-10)
  
  // Environmental & Equipment
  avgTemp         Float?   // Average temperature
  trainer         Boolean? // Indoor trainer workout
  
  // L/R Balance
  lrBalance       Float?   // Left/Right power balance
  
  // Energy & Time
  calories        Int?     // Energy expenditure in kcal (from Strava/Intervals)
  elapsedTimeSec  Int?     // Total elapsed time including stops (vs durationSec which is moving time)
  
  // Device & Metadata
  deviceName      String?  // Device used for tracking (e.g., "Apple Watch Ultra", "Garmin Edge 1030")
  commute         Boolean? @default(false) // Flag for commute workouts (Strava)
  isPrivate       Boolean? @default(false) // Privacy flag (Strava)
  gearId          String?  // Equipment identifier (Strava gear_id)
  
  // AI Analysis
  aiAnalysis      String?  @db.Text // AI-generated workout analysis (markdown fallback)
  aiAnalysisJson  Json?    // Structured analysis data for rich UI display
  aiAnalysisStatus String? @default("NOT_STARTED") // NOT_STARTED, PENDING, PROCESSING, COMPLETED, FAILED
  aiAnalyzedAt    DateTime? // When the analysis was generated
  
  // Performance Scores (1-10 scale for tracking over time)
  overallScore    Int?     // Overall workout quality score
  technicalScore  Int?     // Technical execution (form, technique, efficiency)
  effortScore     Int?     // Effort appropriateness relative to plan
  pacingScore     Int?     // Pacing strategy and execution
  executionScore  Int?     // How well the workout plan was executed
  
  // Score Explanations (AI-generated insights and improvement guidance)
  overallQualityExplanation      String?  @db.Text // Why this overall score, key factors
  technicalExecutionExplanation  String?  @db.Text // Technical analysis and form guidance
  effortManagementExplanation    String?  @db.Text // Effort appropriateness and pacing advice
  pacingStrategyExplanation      String?  @db.Text // Pacing analysis and recommendations
  executionConsistencyExplanation String? @db.Text // Execution quality and consistency notes
  
  // Raw Data storage (for re-analysis and accessing original data)
  rawJson         Json?    // Store the original full payload
  
  // Custom Notes (user-editable rich text notes)
  notes           String?  @db.Text // User's custom notes in markdown format
  notesUpdatedAt  DateTime? // When notes were last updated
  
  // Sharing
  shareToken      String?   @unique

  // Duplicate Detection & Management
  isDuplicate     Boolean  @default(false) // True if this workout is a duplicate
  duplicateOf     String?  // ID of the canonical workout this is a duplicate of
  completenessScore Int?   // Score used to determine which workout is the "best" version
  
  // Planned Workout Link (reverse relationship)
  plannedWorkoutId String? // ID of the planned workout this workout completed
  
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  reports         ReportWorkout[]
  duplicates      Workout[] @relation("WorkoutDuplicates") // Workouts that are duplicates of this one
  canonicalWorkout Workout? @relation("WorkoutDuplicates", fields: [duplicateOf], references: [id], onDelete: SetNull)
  streams         WorkoutStream? // Time-series pacing data
  plannedWorkout  PlannedWorkout? @relation(fields: [plannedWorkoutId], references: [id], onDelete: SetNull)
  
  // Link to raw FIT file
  fitFile         FitFile?

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([userId, date])
  @@index([userId, isDuplicate]) // Optimize queries filtering duplicates
  @@unique([userId, source, externalId]) // Prevent duplicates
}

// Time-series data streams for detailed pacing analysis
model WorkoutStream {
  id              String   @id @default(uuid())
  workoutId       String   @unique
  
  // Raw stream data (stored as JSON arrays)
  time            Json?    // Array of elapsed time in seconds
  distance        Json?    // Array of cumulative distance in meters
  velocity        Json?    // Array of velocity in m/s (pace data!)
  heartrate       Json?    // Array of heart rate values in bpm
  cadence         Json?    // Array of cadence values (rpm/spm)
  watts           Json?    // Array of power values in watts
  altitude        Json?    // Array of altitude values in meters
  latlng          Json?    // Array of [lat, lng] GPS coordinates
  grade           Json?    // Array of grade percentages
  moving          Json?    // Array of boolean moving indicators
  
  // Computed pacing metrics
  avgPacePerKm    Float?   // Average pace in min/km
  paceVariability Float?   // Standard deviation of pace (consistency)
  lapSplits       Json?    // Array of lap/mile/km splits
  paceZones       Json?    // Time in each pace zone
  pacingStrategy  Json?    // Even/positive/negative split analysis
  surges          Json?    // Detected pace surges
  
  workout         Workout  @relation(fields: [workoutId], references: [id], onDelete: Cascade)
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  @@index([workoutId])
}

// Raw FIT file storage
model FitFile {
  id          String   @id @default(uuid())
  userId      String
  filename    String
  fileData    Bytes    // The raw .fit file content
  hash        String   // For deduplication (MD5/SHA256 of content)
  
  workoutId   String?  @unique
  workout     Workout? @relation(fields: [workoutId], references: [id], onDelete: SetNull)
  
  createdAt   DateTime @default(now())
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([hash])
}

// Planned workouts from Intervals.icu
model PlannedWorkout {
  id              String   @id @default(uuid())
  userId          String
  externalId      String   // ID from Intervals.icu
  
  // Core Data
  date            DateTime @db.Date // When the workout is planned for
  title           String
  description     String?  @db.Text
  type            String?  // "Ride", "Run", etc.
  category        String?  // "WORKOUT", "EVENT", "NOTE"
  
  // Planned Metrics
  durationSec     Int?     // Planned duration
  distanceMeters  Float?   // Planned distance
  tss             Float?   // Planned TSS
  workIntensity   Float?   // Planned intensity
  
  // Status
  completed       Boolean? @default(false)
  
  // Sync Management
  syncStatus      String?  @default("SYNCED") // SYNCED, PENDING, FAILED, LOCAL_ONLY
  lastSyncedAt    DateTime?
  syncError       String?  @db.Text
  modifiedLocally Boolean  @default(false)
  
  // Raw Data
  rawJson         Json?    // Store the original full payload
  
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  recommendations ActivityRecommendation[]
  completedWorkouts Workout[] // Workouts that completed this planned workout
  
  shareToken      String?  @unique

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([userId, date])
  @@index([userId, syncStatus])
  @@unique([userId, externalId]) // Prevent duplicates
}

// Normalized Daily Health Data (Recovery, Sleep)
model DailyMetric {
  id             String   @id @default(uuid())
  userId         String
  date           DateTime @db.Date // YYYY-MM-DD
  source         String   // "whoop", "garmin", "oura"

  // Heart & Recovery
  hrv            Float?   // rMSSD (ms)
  restingHr      Int?
  
  // Sleep
  sleepScore     Int?     // 0-100
  hoursSlept     Float?
  
  // Proprietary Scores (Normalized)
  recoveryScore  Int?     // 0-100 (Whoop style)
  strainScore    Float?   // 0-21 (Whoop style) or similar
  
  spO2           Float?

  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, date])
}

// Wellness data from Intervals.icu (synced from various sources like Whoop, Garmin, etc.)
model Wellness {
  id                String   @id @default(uuid())
  userId            String
  date              DateTime @db.Date // YYYY-MM-DD
  
  // Heart Rate Variability
  hrv               Float?   // Heart Rate Variability (ms)
  hrvSdnn           Float?   // HRV SDNN - autonomic nervous system balance
  
  // Heart Rate
  restingHr         Int?     // Resting heart rate
  avgSleepingHr     Int?     // Average sleeping heart rate
  
  // Sleep Metrics
  sleepSecs         Int?     // Total sleep in seconds
  sleepHours        Float?   // Computed: sleepSecs / 3600
  sleepScore        Int?     // Sleep quality score (0-100)
  sleepQuality      Int?     // Sleep quality rating (1-10)
  
  // Recovery & Readiness
  readiness         Int?     // Readiness to train (1-10)
  recoveryScore     Int?     // Recovery score (0-100)
  
  // Subjective Wellness Metrics
  soreness          Int?     // Muscle soreness (1-10)
  fatigue           Int?     // Fatigue level (1-10)
  stress            Int?     // Stress level (1-10)
  mood              Int?     // Mood rating (1-10)
  motivation        Int?     // Motivation level (1-10)
  
  // Physical Metrics
  weight            Float?   // Weight in kg
  spO2              Float?   // Blood oxygen saturation (%)
  
  // Training Load (from Intervals.icu)
  ctl               Float?   // Chronic Training Load (Fitness)
  atl               Float?   // Acute Training Load (Fatigue)
  
  // Notes
  comments          String?  @db.Text
  
  // Raw data for accessing original response
  rawJson           Json?
  
  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  @@unique([userId, date])
  @@index([userId, date])
}

// Nutrition data from Yazio
model Nutrition {
  id                String   @id @default(uuid())
  userId            String
  date              DateTime @db.Date
  
  // Daily Summary
  calories          Int?     // Total calories consumed
  protein           Float?   // Protein in grams
  carbs             Float?   // Carbohydrates in grams
  fat               Float?   // Fat in grams
  fiber             Float?   // Fiber in grams
  sugar             Float?   // Sugar in grams
  
  // Meal Breakdown
  breakfast         Json?    // Breakfast items and macros
  lunch             Json?    // Lunch items and macros
  dinner            Json?    // Dinner items and macros
  snacks            Json?    // Snacks items and macros
  
  // Nutrition Goals vs Actual
  caloriesGoal      Int?
  proteinGoal       Float?
  carbsGoal         Float?
  fatGoal           Float?
  
  // Water intake
  waterMl           Int?     // Water in milliliters
  
  // AI Analysis
  aiAnalysis        String?  @db.Text // AI-generated nutrition analysis (markdown fallback)
  aiAnalysisJson    Json?    // Structured analysis data for rich UI display
  aiAnalysisStatus  String?  @default("NOT_STARTED") // NOT_STARTED, PENDING, PROCESSING, COMPLETED, FAILED
  aiAnalyzedAt      DateTime? // When the analysis was generated
  
  // Nutrition Quality Scores (1-10 scale for tracking over time)
  overallScore      Int?     // Overall nutrition quality score
  macroBalanceScore Int?     // Macro distribution appropriateness
  qualityScore      Int?     // Food quality and nutrient density
  adherenceScore    Int?     // Adherence to goals and targets
  hydrationScore    Int?     // Hydration adequacy
  
  // Score Explanations (AI-generated insights and improvement guidance)
  nutritionalBalanceExplanation  String?  @db.Text // Overall nutrition quality analysis
  calorieAdherenceExplanation    String?  @db.Text // Calorie target adherence and guidance
  macroDistributionExplanation   String?  @db.Text // Macro balance analysis and recommendations
  hydrationStatusExplanation     String?  @db.Text // Hydration adequacy and improvement tips
  timingOptimizationExplanation  String?  @db.Text // Meal timing and optimization guidance
  
  // Raw data for re-analysis
  rawJson           Json?
  
  // Custom Notes (user-editable rich text notes)
  notes             String?  @db.Text // User's custom notes in markdown format
  notesUpdatedAt    DateTime? // When notes were last updated
  
  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  reports           ReportNutrition[]
  
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  
  @@unique([userId, date])
  @@index([userId, date])
}

// Yazio Product Cache - stores product details to avoid rate limiting
model YazioProductCache {
  id              String   @id @default(uuid())
  productId       String   @unique // Yazio product ID
  
  // Product details
  name            String
  brand           String?
  baseUnit        String?  // e.g., "g", "ml"
  
  // Nutritional info per 100g/ml
  nutrients       Json?    // Full nutrient data
  
  // Cache metadata
  fetchedAt       DateTime @default(now())
  expiresAt       DateTime // Long TTL (e.g., 1 year - nutrition rarely changes)
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  @@index([productId])
  @@index([expiresAt])
}

// --------------------------------------
// AI Agent Outputs
// --------------------------------------

model Report {
  id             String   @id @default(uuid())
  userId         String
  type           String   // "WEEKLY_ANALYSIS", "RACE_PREP", "DAILY_SUGGESTION"
  status         String   // "PENDING", "PROCESSING", "COMPLETED", "FAILED"
  
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  
  // Metadata
  dateRangeStart DateTime
  dateRangeEnd   DateTime
  modelVersion   String?  // e.g., "gemini-2.5-pro"
  
  // Content
  markdown       String?  @db.Text  // Markdown fallback for compatibility/exports
  analysisJson   Json?              // Structured analysis data for rich UI display
  latex          String?  @db.Text  // If we generated a formal document
  pdfUrl         String?  // URL to stored PDF in S3/Blob storage
  
  // Performance Scores (1-10 scale for tracking progress)
  overallScore       Int?     // Overall period assessment score
  trainingLoadScore  Int?     // Training load management quality
  recoveryScore      Int?     // Recovery adequacy score
  progressScore      Int?     // Progress and adaptation score
  consistencyScore   Int?     // Training consistency score
  
  // Score Explanations (AI-generated insights and improvement guidance)
  trainingLoadExplanation       String?  @db.Text // Training load analysis and management guidance
  recoveryBalanceExplanation    String?  @db.Text // Recovery adequacy and optimization tips
  progressTrendExplanation      String?  @db.Text // Progress analysis and adaptation insights
  adaptationReadinessExplanation String? @db.Text // Readiness for increased training load
  injuryRiskExplanation         String?  @db.Text // Injury risk assessment and prevention
  
  // Structured Suggestions (for the "Coach" agent)
  suggestions    Json?    // e.g., { "action": "rest", "reason": "HRV low" }

  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  workouts       ReportWorkout[]
  nutrition      ReportNutrition[]
}

// Many-to-many relationship between Reports and Workouts
model ReportWorkout {
  id         String   @id @default(uuid())
  reportId   String
  workoutId  String
  
  report     Report   @relation(fields: [reportId], references: [id], onDelete: Cascade)
  workout    Workout  @relation(fields: [workoutId], references: [id], onDelete: Cascade)
  
  createdAt  DateTime @default(now())
  
  @@unique([reportId, workoutId])
  @@index([reportId])
  @@index([workoutId])
}

// Many-to-many relationship between Reports and Nutrition
model ReportNutrition {
  id          String   @id @default(uuid())
  reportId    String
  nutritionId String
  
  report      Report   @relation(fields: [reportId], references: [id], onDelete: Cascade)
  nutrition   Nutrition @relation(fields: [nutritionId], references: [id], onDelete: Cascade)
  
  createdAt   DateTime @default(now())
  
  @@unique([reportId, nutritionId])
  @@index([reportId])
  @@index([nutritionId])
}

// --------------------------------------
// Activity Recommendations
// --------------------------------------

model ActivityRecommendation {
  id          String   @id @default(uuid())
  userId      String
  date        DateTime @db.Date
  
  // Analysis results
  recommendation String   // proceed, modify, reduce_intensity, rest
  confidence     Float    // 0.0 to 1.0
  reasoning      String   @db.Text
  
  // Structured JSON with full analysis
  analysisJson   Json?
  
  // Linked planned workout (if exists)
  plannedWorkoutId String?
  plannedWorkout   PlannedWorkout? @relation(fields: [plannedWorkoutId], references: [id])
  
  // Status tracking
  status      String   @default("PENDING") // PENDING, PROCESSING, COMPLETED, FAILED
  modelVersion String?
  
  // User actions
  userAccepted Boolean? // Did user accept the recommendation?
  userModified Boolean? // Did user modify before accepting?
  appliedToIntervals Boolean? @default(false) // Synced to Intervals.icu?
  
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@index([userId, date])
}

// --------------------------------------
// Training Plan Management
// --------------------------------------

// User's training availability preferences
model TrainingAvailability {
  id          String   @id @default(uuid())
  userId      String
  
  // Day of week (0 = Sunday, 1 = Monday, ..., 6 = Saturday)
  dayOfWeek   Int      // 0-6
  
  // Time slots available (morning, afternoon, evening)
  morning     Boolean  @default(false) // 5am-12pm
  afternoon   Boolean  @default(false) // 12pm-6pm
  evening     Boolean  @default(false) // 6pm-11pm
  
  // Preferred workout types for this slot
  preferredTypes Json? // Array of workout types: ["Ride", "Run", "Gym", "Swim"]
  
  // Location/equipment constraints
  indoorOnly  Boolean  @default(false)
  outdoorOnly Boolean  @default(false)
  gymAccess   Boolean  @default(false)
  bikeAccess  Boolean  @default(false) // Has bike or indoor trainer access
  
  // Notes
  notes       String?  @db.Text
  
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@unique([userId, dayOfWeek])
  @@index([userId])
}

// AI-Generated weekly training plans
model WeeklyTrainingPlan {
  id                String   @id @default(uuid())
  userId            String
  
  // Plan period
  weekStartDate     DateTime @db.Date  // Monday of the week
  weekEndDate       DateTime @db.Date  // Sunday of the week
  daysPlanned       Int      @default(7) // Number of days planned (default 7)
  
  // Plan metadata
  status            String   @default("DRAFT") // DRAFT, ACTIVE, COMPLETED, ARCHIVED
  generatedBy       String   @default("AI")    // AI, USER, COACH
  modelVersion      String?  // e.g., "gemini-2.0-flash-exp"
  
  // Plan details (JSON structure with daily workouts)
  planJson          Json     // Full plan structure with daily recommendations
  
  // Summary stats
  totalTSS          Float?   // Total planned TSS for the week
  totalDuration     Int?     // Total planned duration in seconds
  workoutCount      Int?     // Number of planned workouts
  
  // User feedback
  userAccepted      Boolean? // Did user accept the plan?
  userModified      Boolean? // Did user modify the plan?
  appliedToIntervals Boolean? @default(false) // Synced to Intervals.icu?
  
  // Notes and adjustments
  notes             String?  @db.Text
  adjustmentReason  String?  @db.Text // Why plan was modified
  
  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  
  @@index([userId, weekStartDate])
  @@index([userId, status])
}

// --------------------------------------
// Score Trend Explanations
// --------------------------------------

// Stores AI-generated trend explanations for workout and nutrition scores
// These are pre-generated for instant access and cached with expiration
model ScoreTrendExplanation {
  id          String   @id @default(uuid())
  userId      String
  
  // Type and metrics
  type        String   // "nutrition" or "workout"
  period      Int      // Number of days (7, 14, 30, 90)
  metric      String   // "overall", "macroBalance", "quality", "adherence", "hydration" OR "overall", "technical", "effort", "pacing", "execution"
  score       Float?   // The average score for this metric
  
  // AI-generated analysis (structured JSON)
  analysisData Json    // Contains: executive_summary, sections[], recommendations[]
  
  // Cache management
  generatedAt DateTime @default(now())
  expiresAt   DateTime // When this explanation should be regenerated
  
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@unique([userId, type, period, metric])
  @@index([userId, type, period])
  @@index([expiresAt]) // For cleanup jobs
}

// --------------------------------------
// Chat System
// --------------------------------------

model ChatRoom {
  id          String   @id @default(uuid())
  name        String?
  avatar      String?
  
  // Relations
  users       ChatParticipant[]
  messages    ChatMessage[]
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model ChatParticipant {
  id          String   @id @default(uuid())
  userId      String
  roomId      String
  
  // Status
  lastSeen    DateTime?
  
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  room        ChatRoom @relation(fields: [roomId], references: [id], onDelete: Cascade)
  
  @@unique([userId, roomId])
}

model ChatMessage {
  id          String   @id @default(uuid())
  content     String   @db.Text
  roomId      String
  senderId    String   // ID of the User who sent it (or 'ai_agent' for bot)
  
  // Metadata
  files       Json?    // Array of file objects if needed
  replyToId   String?  // For threading
  seen        Json?    // Map of userId -> timestamp
  metadata    Json?    // Extended metadata (charts, tool calls, etc.)
  
  room        ChatRoom @relation(fields: [roomId], references: [id], onDelete: Cascade)
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@index([roomId, createdAt])
}

// --------------------------------------
// Sync Queue for Intervals.icu
// --------------------------------------

// Queue for retrying failed sync operations to Intervals.icu
model SyncQueue {
  id            String   @id @default(uuid())
  userId        String
  entityType    String   // "planned_workout", "availability", etc.
  entityId      String   // ID of the entity to sync
  operation     String   // "CREATE", "UPDATE", "DELETE"
  payload       Json     // Data to sync
  status        String   @default("PENDING") // PENDING, PROCESSING, COMPLETED, FAILED
  attempts      Int      @default(0)
  lastAttempt   DateTime?
  error         String?  @db.Text
  completedAt   DateTime?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId, status])
  @@index([status, createdAt])
}

// --------------------------------------
// LLM Usage Tracking
// --------------------------------------

// Tracks all LLM API calls for cost monitoring and analysis
model LlmUsage {
  id              String   @id @default(uuid())
  userId          String?  // User who triggered the call (null for system-level operations)
  
  // Model Information
  provider        String   // "gemini", "openai", etc.
  model           String   // "gemini-flash-latest", "gpt-4", etc.
  modelType       String?  // "flash", "pro" (for internal model type categorization)
  
  // Operation Context
  operation       String   // "workout_analysis", "nutrition_analysis", "weekly_report", "chat", etc.
  entityType      String?  // "Workout", "Nutrition", "Report", "ChatMessage", etc.
  entityId        String?  // ID of the related entity
  
  // Token Usage
  promptTokens    Int?     // Number of input tokens
  completionTokens Int?    // Number of output tokens
  totalTokens     Int?     // Total tokens used
  
  // Cost Tracking (in USD)
  estimatedCost   Float?   // Estimated cost in USD
  
  // Performance Metrics
  durationMs      Int?     // Time taken in milliseconds
  retryCount      Int      @default(0) // Number of retries due to rate limiting
  
  // Status
  success         Boolean  // Whether the call succeeded
  errorType       String?  // "rate_limit", "api_error", "timeout", etc.
  errorMessage    String?  @db.Text
  
  // Request/Response Data (for debugging)
  promptPreview   String?  @db.Text // First 500 chars of prompt (for quick preview)
  responsePreview String?  @db.Text // First 500 chars of response (for quick preview)
  promptFull      String?  @db.Text // Complete prompt (for full debugging)
  responseFull    String?  @db.Text // Complete response (for full debugging)
  
  // Relations
  user            User?    @relation(fields: [userId], references: [id], onDelete: SetNull)
  
  createdAt       DateTime @default(now())
  
  @@index([userId, createdAt])
  @@index([operation, createdAt])
  @@index([provider, model, createdAt])
  @@index([success, createdAt])
}
